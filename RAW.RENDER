   SUBROUTINE RAW.RENDER(MAT ENV,ENV.SIZE,MAT FILES,FILE.CTR,TEMPLATE,RESULT)
*
   GIT.FILENAME = 'RAW.RENDER'
   GIT.REPO = 'https://github.com/Krowemoh/basic-template-language.git'
*
   DIM ENV(ENV.SIZE)
*
   EQU TRUE TO 1
   EQU FALSE TO 0
*
   EQU FOR.TOKEN TO 1
*
   NUMBER.OF.LINES = DCOUNT(TEMPLATE,@AM)
*
   FOR I = 1 TO NUMBER.OF.LINES
      LINE = TRIM(TEMPLATE<I>)
      LINE.LEN = LEN(LINE)
*
      IF LINE[1,2] = '{{' AND LINE[LINE.LEN-1,2] = '}}' THEN
         BASIC.LINE = TRIM(LINE[3,LINE.LEN-4])
*
         FIRST.TOKEN = FIELD(BASIC.LINE,' ',1)
         LINE = FIELD(BASIC.LINE,' ',2,999)
*
         BEGIN CASE
            CASE FIRST.TOKEN = 'FOR'
               LINE = CHANGE(LINE,' TO ',@AM)
               LINE = CHANGE(LINE,'=',@VM,1)
*
               RH = TRIM(FIELD(LINE,@AM,1))
               LOOP.VAR = TRIM(FIELD(RH,@VM,1))
               START.EXPR = TRIM(FIELD(RH,@VM,2,999))
*
               END.EXPR = TRIM(FIELD(LINE,@AM,2))
*
               END.STATEMENT = 'NEXT ' : LOOP.VAR : ' '
               BLOCK = ''
*
               LOOP
                  I = I + 1
                  LINE = TRIM(TEMPLATE<I>)
               UNTIL INDEX(LINE,END.STATEMENT,1) # 0 OR I > NUMBER.OF.LINES DO
                  BLOCK<-1> = LINE
               REPEAT
*
               CALL EVALUATE(MAT ENV,ENV.SIZE,START.EXPR,LOOP.START)
               CALL EVALUATE(MAT ENV,ENV.SIZE,END.EXPR,LOOP.END)
*
               FOR LOOP.INDEX = LOOP.START TO LOOP.END
                  CALL MAP.SET(MAT ENV,ENV.SIZE,LOOP.VAR,LOOP.INDEX)
                  RESULT.TEMP = ''
                  CALL RAW.RENDER(MAT ENV,ENV.SIZE,MAT FILES,FILE.CTR,BLOCK,RESULT.TEMP)
                  RESULT<-1> = RESULT.TEMP
               NEXT LOOP.INDEX
*
            CASE FIRST.TOKEN = 'IF'
               CONDITIONS = ''
               BLOCKS = ''
*
               GOSUB BUILD.BLOCKS
*
               I = J - 1
*
               NUMBER.OF.CONDITIONS = DCOUNT(CONDITIONS,@AM)
*
               CONDITION.MET = FALSE
*
               FOR COND.CTR = 1 TO NUMBER.OF.CONDITIONS UNTIL CONDITION.MET
                  C.EXPR = CONDITIONS<COND.CTR>
                  BLOCK = BLOCKS<COND.CTR>
                  IF C.EXPR = '' THEN
                     RESULT.TEMP = ''
                     CALL RAW.RENDER(MAT ENV,ENV.SIZE,MAT FILES,FILE.CTR,BLOCK,RESULT.TEMP)
                     RESULT<-1> = RESULT.TEMP
                     CONDITION.MET = TRUE
*
                  END ELSE IF BLOCK # '' THEN
                     CALL EVALUATE(MAT ENV,ENV.SIZE,C.EXPR,COND.RESULT)
                     IF COND.RESULT = 1 THEN
                        RESULT.TEMP = ''
                        CALL RAW.RENDER(MAT ENV,ENV.SIZE,MAT FILES,FILE.CTR,BLOCK,RESULT.TEMP)
                        RESULT<-1> = RESULT.TEMP
                        CONDITION.MET = TRUE
                     END
                  END
               NEXT COND.CTR
*
            CASE FIRST.TOKEN = 'OPEN'
               CONDITIONS = ''
               BLOCKS = ''
*
               GOSUB BUILD.BLOCKS
*
               I = J - 1
*
               OPEN.STATEMENT = CONDITIONS<1>
               OPEN.STATEMENT = CHANGE(OPEN.STATEMENT,'OPEN ','',1)
               OPEN.STATEMENT = CHANGE(OPEN.STATEMENT,' TO ',@AM)
*
               FILENAME.EXPR = OPEN.STATEMENT<1>
*
               IF INDEX(FILENAME.EXPR,',',1) = 0 THEN
                  DICT = ''
               END ELSE
                  DICT = FIELD(FILENAME.EXPR,',',1)
                  FILENAME.EXPR = FIELD(FILENAME.EXPR,',',2)
               END
*
               FILENAME.IDENT = TRIM(OPEN.STATEMENT<2>)
*
               TRUE.BLOCK = BLOCKS<1>
               FALSE.BLOCK = BLOCKS<2>
*
               CALL EVALUATE(MAT ENV,ENV.SIZE,FILENAME.EXPR,FILE.NAME)
*
               OPEN DICT,FILE.NAME TO FILE.POINTER THEN
                  IF TRUE.BLOCK # '' THEN
                     FILE.CTR = FILE.CTR + 1
                     CALL MAP.SET(MAT ENV,ENV.SIZE,FILENAME.IDENT,FILE.CTR)
                     FILES(FILE.CTR) = FILE.POINTER
*
                     RESULT.TEMP = ''
                     CALL RAW.RENDER(MAT ENV,ENV.SIZE,MAT FILES,FILE.CTR,TRUE.BLOCK,RESULT.TEMP)
                     RESULT<-1> = RESULT.TEMP
                  END
*
               END ELSE
                  IF FALSE.BLOCK = '' THEN
                     PRINT 'Failed to open file: ' : FILE.NAME
                     STOP
                  END ELSE
                     RESULT.TEMP = ''
                     CALL RAW.RENDER(MAT ENV,ENV.SIZE,MAT FILES,FILE.CTR,FALSE.BLOCK,RESULT.TEMP)
                     RESULT<-1> = RESULT.TEMP
                  END
               END
*
            CASE FIRST.TOKEN = 'READ'
               CONDITIONS = ''
               BLOCKS = ''
*
               GOSUB BUILD.BLOCKS
*
               I = J - 1
*
               READ.STATEMENT = CONDITIONS<1>
               READ.STATEMENT = CHANGE(READ.STATEMENT,'READ ','',1)
               READ.STATEMENT = CHANGE(READ.STATEMENT,' FROM ',@AM)
*
               VAR.NAME = TRIM(READ.STATEMENT<1>)
*
               RH = TRIM(READ.STATEMENT<2>)
               RH = CHANGE(RH,',',@AM,1)
*
               FILE.NAME = TRIM(RH<1>)
               RECORD.ID.EXPR = TRIM(RH<2>)
*
               TRUE.BLOCK = BLOCKS<1>
               FALSE.BLOCK = BLOCKS<2>
*
               CALL EVALUATE(MAT ENV,ENV.SIZE,RECORD.ID.EXPR,RECORD.ID)
*
               CALL MAP.GET(MAT ENV,ENV.SIZE,FILE.NAME,FILE.NUMBER)
*
               IF FILE.NUMBER = '' THEN
                  PRINT 'Render Error File not open - ' : FILE.NAME
                  STOP
               END
*
               FILE.POINTER = FILES(FILE.NUMBER)
*
               READ RECORD FROM FILE.POINTER,RECORD.ID THEN
                  CALL MAP.SET(MAT ENV,ENV.SIZE,VAR.NAME,RECORD)
                  IF TRUE.BLOCK # '' THEN
                     RESULT.TEMP = ''
                     CALL RAW.RENDER(MAT ENV,ENV.SIZE,MAT FILES,FILE.CTR,TRUE.BLOCK,RESULT.TEMP)
                     RESULT<-1> = RESULT.TEMP
                  END
               END ELSE
                  IF FALSE.BLOCK # '' THEN
                     RESULT.TEMP = ''
                     CALL RAW.RENDER(MAT ENV,ENV.SIZE,MAT FILES,FILE.CTR,FALSE.BLOCK,RESULT.TEMP)
                     RESULT<-1> = RESULT.TEMP
                  END ELSE
                     PRINT 'Failed to read record: ' : RECORD.ID
                  END
               END
*
            CASE FIRST.TOKEN = 'INCLUDE'
               FILE.NAME.EXPR = FIELD(BASIC.LINE,' ',2)
               RECORD.NAME.EXPR = FIELD(BASIC.LINE,' ',3)
*
               CALL EVALUATE(MAT ENV,ENV.SIZE,FILE.NAME.EXPR,FILE.NAME)
               CALL EVALUATE(MAT ENV,ENV.SIZE,RECORD.NAME.EXPR,RECORD.ID)
*
               OPEN '',FILE.NAME TO INCLUDE.FILE ELSE
                  PRINT 'Failed to open: ' : FILE.NAME
                  STOP
               END
*
               READ RECORD FROM INCLUDE.FILE,RECORD.ID ELSE
                  PRINT 'Failed to read: ' : RECORD.ID
                  STOP
               END
*
               RESULT.TEMP = ''
               CALL RAW.RENDER(MAT ENV,ENV.SIZE,MAT FILES,FILE.CTR,RECORD,RESULT.TEMP)
               RESULT<-1> = RESULT.TEMP
*
            CASE FIRST.TOKEN = 'PRINT'
               CALL EVALUATE(MAT ENV,ENV.SIZE,LINE,EVAL.RESULT)
               PRINT EVAL.RESULT
*
            CASE FIRST.TOKEN = 'CALL'
               CALL EVALUATE(MAT ENV,ENV.SIZE,LINE,EVAL.RESULT)
*
            CASE TRUE
               IF INDEX(BASIC.LINE,'=',1) = 0 THEN
                  CALL EVALUATE(MAT ENV,ENV.SIZE,BASIC.LINE,VALUE)
                  RESULT<-1> = VALUE
*
               END ELSE
                  BASIC.LINE = CHANGE(BASIC.LINE,'=',@AM,1)
*
                  RH = TRIM(FIELD(BASIC.LINE,@AM,1))
                  LH = TRIM(FIELD(BASIC.LINE,@AM,2))
*
                  CALL EVALUATE(MAT ENV,ENV.SIZE,LH,VALUE)
                  CALL MAP.SET(MAT ENV,ENV.SIZE,RH,VALUE)
               END
*
         END CASE
*
      END ELSE
         LINE = CHANGE(LINE,'{{',@AM:'{{')
         LINE = CHANGE(LINE,'}}','}}':@AM)
*
         NUMBER.OF.BREAKS = DCOUNT(LINE,@AM)
         L = ''
*
         FOR B.CTR = 1 TO NUMBER.OF.BREAKS
            PIECE = LINE<B.CTR>
            PIECE.LEN = LEN(PIECE)
*
            IF PIECE[1,2] = '{{' THEN
               BASIC.LINE = TRIM(PIECE[3,PIECE.LEN-4])
*
               IF INDEX(PIECE,'=',1) = 0 THEN
                  CALL EVALUATE(MAT ENV,ENV.SIZE,BASIC.LINE,VALUE)
                  L = L : VALUE
*
               END ELSE
                  BASIC.LINE = CHANGE(BASIC.LINE,'=',@AM,1)
*
                  RH = TRIM(FIELD(BASIC.LINE,@AM,1))
                  LH = TRIM(FIELD(BASIC.LINE,@AM,2))
*
                  CALL EVALUATE(MAT ENV,ENV.SIZE,LH,VALUE)
                  CALL MAP.SET(MAT ENV,ENV.SIZE,RH,VALUE)
               END
*
            END ELSE
               L = L : PIECE
            END
         NEXT B.CTR
*
         RESULT<-1> = L
      END
   NEXT I
*
   CONVERT @AM TO CHAR(10) IN RESULT
*
   RETURN
*
*********************  S U B R O U T I N E  *********************
*
BUILD.BLOCKS:NULL
*
   LAST.TOKEN = FIELD(BASIC.LINE,' ',DCOUNT(BASIC.LINE,' '))
*
   CONDITIONS = ''
   BLOCKS = ''
   BLOCK = ''
*
   STACK.CTR = 0
*
   BLOCK.DONE = FALSE
*
   THEN.CHECK = INDEX(BASIC.LINE,' THEN ',1)
   ELSE.CHECK = INDEX(BASIC.LINE,' ELSE ',1)
*
   IF THEN.CHECK = 0 AND  ELSE.CHECK = 0 THEN
      BASIC.LINE = BASIC.LINE : ' THEN  ELSE '
   END ELSE IF THEN.CHECK = 0 THEN
      BASIC.LINE = CHANGE(BASIC.LINE,' ELSE ',' THEN  ELSE ',1)
   END ELSE
      BASIC.LINE = CHANGE(BASIC.LINE,' THEN ',' THEN  ELSE ',1)
   END
*
   IF LAST.TOKEN # 'THEN' AND LAST.TOKEN # 'ELSE' THEN
      BASIC.LINE = CHANGE(BASIC.LINE,' THEN ',' THEN':@AM,1)
*
      IF INDEX(BASIC.LINE,' END ELSE ',1) # 0 THEN
         BASIC.LINE = CHANGE(BASIC.LINE,' END ELSE ',@AM:' END ELSE':@AM,1)
      END ELSE
         BASIC.LINE = CHANGE(BASIC.LINE,' ELSE ',@AM:' END ELSE ':@AM,1)
      END
*
      BASIC.LINE<-1> = 'END'
*
      NUMBER.OF.ELEMENTS = DCOUNT(BASIC.LINE,@AM)
*
      TEMPLATE = DELETE(TEMPLATE,I)
*
      FOR E.CTR = NUMBER.OF.ELEMENTS TO 1 STEP -1
         ELEMENT = '{{ ' : TRIM(BASIC.LINE<E.CTR>) : ' }}'
         TEMPLATE = INSERT(TEMPLATE,I;ELEMENT)
      NEXT E.CTR
*
      NUMBER.OF.LINES = DCOUNT(TEMPLATE,@AM)
   END
*
   FOR J = I TO NUMBER.OF.LINES UNTIL BLOCK.DONE
      LINE = TRIM(TEMPLATE<J>)
      LINE.LEN = LEN(LINE)
*
      IF LINE[1,2] = '{{' AND LINE[2] = '}}' THEN
         BASIC.LINE = TRIM(LINE[3,LINE.LEN-4])
*
         FIRST.TOKEN = FIELD(BASIC.LINE,' ',1)
         LAST.TOKEN = FIELD(BASIC.LINE,' ',DCOUNT(BASIC.LINE,' '))
*
         IF FIRST.TOKEN = 'END' THEN
            STACK.CTR = STACK.CTR - 1
         END
*
         IF STACK.CTR = 0 THEN
            BLOCKS<-1> = BLOCK
            BLOCK = ''
         END
*
         IF LAST.TOKEN = 'THEN' OR LAST.TOKEN = 'ELSE' OR LAST.TOKEN = 'LOCKED' THEN
            STACK.CTR = STACK.CTR + 1
*
            IF STACK.CTR = 1 THEN
               BASIC.LINE = CHANGE(BASIC.LINE,'END ELSE IF ','',1)
               BASIC.LINE = CHANGE(BASIC.LINE,'END ELSE','',1)
               BASIC.LINE = CHANGE(BASIC.LINE,'IF ','',1)
               BASIC.LINE = BASIC.LINE[1,LEN(BASIC.LINE)-4]
*
               CONDITIONS<-1> = BASIC.LINE
            END ELSE
               BLOCK<1,-1> = LINE
            END
         END ELSE
            BLOCK<1,-1> = LINE
         END
*
         IF STACK.CTR = 0 THEN
            BLOCK.DONE = TRUE
         END
*
      END ELSE
         BLOCK<1,-1> = LINE
      END
   NEXT J
*
   RETURN
*
* END OF PROGRAM
*
   END
*
   

